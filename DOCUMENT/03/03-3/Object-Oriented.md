```markdown
# 객체지향 프로그래밍 (Object-Oriented Programming, OOP)

**C 언어**는 절차지향적 언어이고, **C++**은 **객체지향적 언어**입니다.

### 객체 = "Object" = "사물 또는 대상"

**객체지향 프로그래밍**은 현실에 존재하는 **사물과 대상**, 그리고 그에 따른 **행동**을 있는 그대로 실체화시키는 형태의 프로그래밍입니다.

예를 들어:

> **"나는 과일장수에게 두 개의 사과를 구매했다."**

이 문장에서 객체는 `나(me)`, `과일장수`, `사과`이며, **객체지향 프로그래밍**은 이러한 **객체**들을 등장시킬 수 있을 뿐만 아니라, '나'라는 객체가 '과일장수'라는 객체로부터 '과일' 객체를 **구매하는 행위**까지 표현할 수 있습니다.

### 객체의 구성(데이터와 기능)

결국, **함수**는 객체의 **행동**이며, 객체는 **하나 이상의 상태 정보(데이터)**와 **하나 이상의 행동(기능)**으로 구성됩니다.

- 보유하고 있는 사과의 수 -> int numOfApples;
- 판매 수익 -> int myMoney

과일 장수의 행위

int SaleApples(int money) // 사과 구매액이 함수의 인자로 전달
{
    int num = money/1000; // 사과가 개당 1000원이라고 가정
    numOfApples -= num; // 사과의 수가 줄어들고,
    myMoney += money; // 판매 수익이 발생
    return num; // 실제 구매가 발생한 사과의 수를 반환
}

위와 같이 **과일장수** 행위에 대해서 선언할 수 있고 **나(me)**에 대해서 구매하는 행위도 정의할 수 있다.

### 객체지향의 특징

- **클래스의 멤버변수 선언문에서 초기화는 허용되지 않는다.** (예: C++)  
  (단, 파이썬은 가능합니다.)
  
- **상수**는 선언과 동시에 **초기화**되어야 합니다.

```cpp
class FruitSeller {
public:
    static const int APPLE_PRICE;  // 클래스 멤버로 상수 선언
    //...
};
int main(void)
{
    const int APPLE_PRICE = 1000;  // 상수는 선언과 동시에 초기화(함수 외부)
}
```

- 사과의 판매 가격은 일정하지만, 현재로써는 `APPLE_PRICE`를 **상수로 선언할 방법이 없다**.

#### 메세지전달

```cpp
void BuyApples(FruitSeller &seller, int money) // & 참조를 이용해서 함수 호출
    {
        numOfApples+=seller.SaleApples(money); 
        myMoney-=money;
    }
```
하나의 객체가 다른 하나의 객체에게 메시지를 전달(어떠한 행위의 요구를 위한)하는 방법은 **함수 호출을 기반**으로 한다.
객체지향에서는 이러한 형태의 함수호출을 가리켜 **메시지전달(Message Passing)**이라 한다.

## 클래스 기반의 두 가지 객체생성 방법

```cpp
ClassName objname; // 일반적인 변수의 선언방식
ClassName * ptrObj=new ClassName; // 동적 할당방식(힙 할당방식)
```

## [사과장수 예제](/DOCUMENT/03/03-3/FruitSaleSim1.cpp)
